# UML

- UML (Unified Modeling Language) — это унифицированный язык моделирования, используемый для визуализации,
  проектирования и документирования систем в области программного обеспечения. UML помогает описывать структуру и
  поведение системы с помощью диаграмм (например, диаграммы классов, последовательностей или состояний).

# Паттерн проектирования

- Паттерн проектирования — это типовое решение часто встречающейся задачи в программировании. Он предоставляет готовую
  структуру или подход, которые можно адаптировать для конкретного проекта, упрощая разработку и улучшая читаемость,
  поддержку и масштабируемость кода. Примеры: Singleton, Factory, Observer.
    - Паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.
    - Паттерны — на самом деле, просто описание то, как парочка классов относится и взаимодействует друг с другом.

- Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
- Структурные паттерны показывают различные способы построения связей между объектами.
- Поведенческие паттерны заботятся об эффективной коммуникации между объектами.

___

# Качества хорошей архитектуры

## Повторное использование кода

Повторное использование кода можно представить в трёх уровнях:

- **Классы** (нижний уровень): Это отдельные куски кода, такие как библиотеки и контейнеры, которые можно использовать
  для выполнения определённых задач. Пример: класс для работы с файлами.
- **Паттерны** проектирования (средний уровень): Это шаблоны, которые показывают, как несколько классов могут
  взаимодействовать. Это не конкретный код, а идеи. Пример: паттерн «Одиночка» для создания единственного экземпляра
  класса.
- **Фреймворки** (верхний уровень): Это готовая структура для создания приложений. Вы добавляете своё поведение в
  существующую архитектуру. Пример: JUnit для тестирования. Фреймворк сам вызывает ваши классы в нужный момент.

___

# Базовые принципы проектирования

- ### Инкапсулируйте то, что меняется
    - Определите аспекты программы, класса или метода, которые меняются чаще всего, и отделите их от того, что остаётся
      постоянным.
    - [Файл с реализацией кода - encapsulate_what_changes.py](https://github.com/COD-e-x/design_patterns_lab/blob/main/design_patterns_immersion_book/patterns_basics/encapsulate_what_changes.py)
  
- ### Программируйте на уровне интерфейса (ABC)
    - Программируйте на уровне интерфейса, а не на уровне реализации. Код должен зависеть от абстракций, а не конкретных
      классов.
        - **1.** Определите, что именно нужно одному объекту от другого, какие методы он вызывает.
        - **2.** Затем опишите эти методы в отдельном интерфейсе (ABC).
        - **3.** Сделайте так, чтобы класс-зависимость следовал этому интерфейсу (ABC). Скорее всего, нужно будет только
          добавить этот интерфейс (ABC) в описание класса.
        - **4.** Теперь вы можете сделать и второй класс зависимым от интерфейса (ABC), а не конкретного класса.
    - [Файл с реализацией кода - program_to_interface_1.py](https://github.com/COD-e-x/design_patterns_lab/tree/blob/design_patterns_immersion_book/patterns_basics/program_to_interface_1.py)
    - [Файл с реализацией кода - program_to_interface._2py](https://github.com/COD-e-x/design_patterns_lab/tree/blob/design_patterns_immersion_book/patterns_basics/program_to_interface_2.py)

- ### Предпочитайте композицию наследованию

  - Наследование — это быстрый способ повторного использования кода, но с ростом программы оно может привести к проблемам, 
        которые сложно исправить. Вместо создания базового класса для дублирующегося кода, рассмотрите использование композиции, чтобы избежать этих проблем.
    - В абстрактных классах (ABC) подкласс не может отказаться от интерфейса родителя и обязан реализовать 
        все абстрактные методы.
    - Переопределяя методы родителя, важно не нарушить базовое поведение суперкласса.
    - Наследование нарушает инкапсуляцию, так как подклассы получают доступ к деталям родителя.
    - Подклассы слишком зависят от родителя, что делает изменения в нем рискованными.
    - Наследование может привести к разрастанию иерархии классов.
  - [Файл с реализацией кода - prefer_composition_over_inheritance.py](https://github.com/COD-e-x/design_patterns_lab/blob/main/design_patterns_immersion_book/patterns_basics/prefer_composition_over_inheritance.py)

    ### НАСЛЕДОВАНИЕ: развитие классов в нескольких плоскостях (тип груза × тип двигателя × тип навигации) приводит к комбинаторному взрыву.

> **Комбинаторный взрыв** — это ситуация, когда количество возможных вариантов (или комбинаций) растёт слишком быстро, 
    что делает задачу сложной для решения. Рассмотрим пример: вам нужно выбрать один товар из 3 категорий:
>
> - 3 типа груза
> - 2 типа двигателя
> - 4 типа навигации
>
> Чтобы покрыть все возможные комбинации этих типов, нужно создать 3 × 2 × 4 = 24 разных варианта. Если добавить ещё 
    одну категорию, число комбинаций ещё увеличится. Когда таких категорий становится слишком много, количество 
    вариантов растёт экспоненциально, что делает решение задачи сложным и требующим много времени.
